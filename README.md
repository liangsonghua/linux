**sar 找出系统瓶颈的利器**
> sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。
> 
> sar是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；<br/> 
1.追溯过去的统计数据（默认）<br/>
2.周期性的查看当前数据<br/>

# **6.1. 监控CPU**<br/> #
## 查看CPU使用率 ##
![](http://i.imgur.com/v0k2ztu.png)

  后面的两个参数表示监控的频率，比如例子中的1和2，表示每秒采样一次，总共采样2次；
例如，每60秒采样一次，连续采样5次，观察CPU 的使用情况，并将采样结果以二进制形式存入当前目录下的文件**zhou**中，需键入如下命令 `# sar -u -o  zhou 60 5 ` 

 
     %user 用户模式下消耗的CPU时间的比例；
     %nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例
     %system 系统模式下消耗的CPU时间的比例；
     %iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；
     %steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；
     %idle CPU空闲时间比例；

**## 查看CPU平均负载 ##**
![](http://i.imgur.com/4gQEEUK.png)
 
sar指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；
runq-sz：运行队列的长度（等待运行的进程数）
plist-sz：进程列表中进程（processes）和线程（threads）的数量
ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载
ldavg-15：过去15分钟的系统平均负载
要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来；<br/>
**1. •	怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看<br/>
1. •	怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看<br/>
1. •	怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看<br/>**
# 6.2. 查询内存 #
查看内存使用状况 sar指定-r之后，可查看内存使用状况;


    [root@localhost sysstat-10.2.1]# sar -r 1 2


![](http://i.imgur.com/l7f3QZj.png)

    kbmemfree	可用的空闲内存数量，单位为 KB
    kbmemused	已使用的内存数量（不包含内核使用的内存），单位为 KB
    %memused	已使用内存的百分数
    kbbuffers	内核缓冲区（buffer）使用的内存数量，单位为 KB
    kbcached	内核高速缓存（cache）数据使用的内存数量，单位为 KB
    kbswpfree	可用的空闲交换空间数量，单位为 KB
    kbswpused	已使用的交换空间数量，单位为 KB
    %swpused	已使用交换空间的百分数
    kbswpcad	交换空间的高速缓存使用的内存数量

查看内存使用量

    $free -m
![](http://i.imgur.com/GXfoxmk.png)
 
> 为方便说明把free的输出看成一个二维数组FO(Free Output)<br/>

**FO[2][4]**表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的。<br/>
**FO[2][4]**表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。<br/>
**FO[2][5]**表示被OS buffer住的内存。<br/>
**FO[2][6]**表示被OS cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理 <br/>
**FO[3][2]**，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；<br/>
**FO[3][3]**，即+buffers/cache，表示一个应用程序认为系统还有多少内存；<br/>
因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。
